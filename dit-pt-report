#!/usr/bin/env bash
set -euo pipefail

# Report generator version
REPORT_VERSION="1.4.0"
REPORT_GENERATED_AT="$(date -u '+%Y-%m-%d %H:%M:%S UTC')"

usage() {
  cat <<EOF
dit-pt-report

Generate reports from Nuclei JSONL output.

Usage:
  dit-pt-report --in FILE.jsonl [--out-dir DIR] [--prefix NAME] [--hosts-file FILE]

Options:
  --in FILE.jsonl         Input nuclei JSONL file (required)
  --out-dir DIR           Output directory (default: current dir)
  --prefix NAME           Output filename prefix (default: input filename w/o .jsonl)
  --hosts-file FILE       Optional: host inventory file with `ip mac vendor` (default: /var/lib/dit-pt/targets/hosts)
  -h, --help              Show help
EOF
}

die() { echo "[-] $*" >&2; exit 1; }

check_requirements() {
  local missing=0
  for cmd in jq; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      echo "[-] Missing required tool: $cmd" >&2
      missing=1
    fi
  done

  if [[ "$missing" -eq 1 ]]; then
    echo >&2
    echo "Install missing dependencies and re-run." >&2
    echo >&2
    echo "Examples:" >&2
    echo "  Debian/Ubuntu: sudo apt install jq" >&2
    echo "  RHEL/CentOS : sudo dnf install jq" >&2
    echo "  Arch       : sudo pacman -S jq" >&2
    echo "  macOS      : brew install jq" >&2
    exit 1
  fi
}

IN=""
OUT_DIR="."
PREFIX=""
HOSTS_FILE="/var/lib/dit-pt/targets/hosts"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --in) IN="$2"; shift 2 ;;
    --out-dir) OUT_DIR="$2"; shift 2 ;;
    --prefix) PREFIX="$2"; shift 2 ;;
    --hosts-file) HOSTS_FILE="$2"; shift 2 ;;
    -h|--help) usage; exit 0 ;;
    *) die "Unknown argument: $1" ;;
  esac
done

[[ -n "$IN" ]] || die "--in is required"
[[ -f "$IN" ]] || die "Input file not found: $IN"

check_requirements
mkdir -p "$OUT_DIR"

if [[ -z "$PREFIX" ]]; then
  PREFIX="$(basename "$IN" .jsonl)"
fi

MD_OUT="$OUT_DIR/$PREFIX.md"
CSV_OUT="$OUT_DIR/$PREFIX.csv"

echo "[*] Generating report from $IN"

# --------------------
# CSV OUTPUT
# --------------------
jq -r '
  [
    (.timestamp // ""),
    (.host // "unknown-host"),
    (.url // .["matched-at"] // ""),
    (.info.severity // "unknown"),
    (."template-id" // "unknown-template"),
    (.info.name // "(no name)"),
    (.["matcher-name"] // "")
  ] | @csv
' "$IN" > "$CSV_OUT"

# --------------------
# MARKDOWN REPORT
# --------------------
{
  echo "# dit-pt Findings Report"
  echo
  echo "**Report Generator:** dit-pt-report v${REPORT_VERSION}"
  echo "**Generated:** ${REPORT_GENERATED_AT}"
  echo "**Source:** \`$IN\`"
  if [[ -f "$HOSTS_FILE" ]]; then
    echo "**Host inventory:** \`$HOSTS_FILE\`"
  fi
  echo

echo "## Summary by Severity"
# Show both total matches and unique templates per severity
jq -r '
  [
    (.info.severity // "unknown"),
    (."template-id" // "unknown-template")
  ] | @tsv
' "$IN"   | sort -t$'	' -k1,1 -k2,2   | awk -F'	' '
    {
      sev=$1; tid=$2
      matches[sev]++
      if (!seen[sev,tid]++) uniq[sev]++
    }
    END {
      # Print in severity priority order when present
      order[1]="critical"; order[2]="high"; order[3]="medium"; order[4]="low"; order[5]="info"; order[6]="unknown"
      for (i=1;i<=6;i++){
        s=order[i]
        if (matches[s]>0) printf "- **%s**: %d match(es) (%d unique template(s))\n", s, matches[s], uniq[s]
      }
      # Print any other severities encountered
      for (s in matches){
        if (s!="critical" && s!="high" && s!="medium" && s!="low" && s!="info" && s!="unknown"){
          printf "- **%s**: %d match(es) (%d unique template(s))\n", s, matches[s], uniq[s]
        }
      }
    }
  '
echo

echo "## Top Hosts"
# Show both total matches and unique templates per host
jq -r '
  [
    (.host // "unknown-host"),
    (."template-id" // "unknown-template")
  ] | @tsv
' "$IN"   | sort -t$'	' -k1,1 -k2,2   | awk -F'	' '
    {
      h=$1; tid=$2
      matches[h]++
      if (!seen[h,tid]++) uniq[h]++
    }
    END {
      for (h in matches) {
        printf "%d	%d	%s\n", matches[h], uniq[h], h
      }
    }
  '   | sort -nr -k1,1 -k2,2   | head   | awk -F'	' '{printf "- `%s`: %d match(es) (%d unique template(s))\n",$3,$1,$2}'
echo

echo "## Findings by Host"

  echo

  jq -r '
    [
      (.host // "unknown-host"),
      (.info.severity // "unknown"),
      (."template-id" // "unknown-template"),
      (.info.name // "(no name)"),
      (.url // .["matched-at"] // ""),
      (.["matcher-name"] // "")
    ] | @tsv
  ' "$IN" \
  | sort \
  | awk -F'	' -v hostfile="$HOSTS_FILE" '
  function trim(s){ sub(/^\s+/,"",s); sub(/\s+$/,"",s); return s }
  function norm_host(h,   t) {
    # Extract a comparable key (prefer bare IP/host without scheme/port/path)
    t=h
    sub(/^https?:\/\//,"",t)
    sub(/\/.*$/,"",t)
    sub(/^\[/,"",t)
    sub(/\]$/,"",t)
    split(t, a, ":")
    return a[1]
  }
  function load_host_inventory(   line, ip) {
    if (hostfile=="" ) return
    # Accept lines like: "IP MAC VENDOR..."; keep the full line for display
    while ((getline line < hostfile) > 0) {
      line = trim(line)
      if (line=="" || line ~ /^#/) continue
      split(line, f, /[[:space:]]+/)
      ip=f[1]
      if (ip ~ /^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/) {
        hostline[ip]=line
      }
    }
    close(hostfile)
  }

  BEGIN { load_host_inventory() }

  function sev_icon(s) {
    if (s=="critical") return "üî•";
    if (s=="high")     return "‚ùó";
    if (s=="medium")   return "‚ö†Ô∏è";
    if (s=="low")      return "üü°";
    return "‚ÑπÔ∏è";
  }
  function sev_rank(s) {
    if (s=="critical") return 1;
    if (s=="high")     return 2;
    if (s=="medium")   return 3;
    if (s=="low")      return 4;
    return 5;  # info / unknown
  }

  {
    host=$1; sev=$2; tid=$3; name=$4; url=$5; matcher=$6;
    key = host SUBSEP sev SUBSEP tid;

    hosts[host]=1;
    sev_seen[host,sev]=1;
    title[key]=name;
    count[key]++;

    # Track worst (highest priority) severity per host for sorting hosts
    if (!(host in worst) || sev_rank(sev) < worst[host]) {
      worst[host] = sev_rank(sev)
    }

    if (url != "") {
      if (!(seen[key,url]++)) {
        urls[key] = urls[key] "\n  - " url;
      }
    }

    if (matcher != "") {
      if (!(seenm[key,matcher]++)) {
        details[key] = details[key] "\n  - " matcher;
      }
    }
  }

  END {
    # Build host list
    n = 0
    for (h in hosts) {
      hostlist[++n] = h
    }

    # Sort hosts by worst severity (ascending rank = higher priority)
    for (i = 1; i <= n; i++) {
      for (j = i + 1; j <= n; j++) {
        if (worst[hostlist[j]] < worst[hostlist[i]]) {
          tmp = hostlist[i]
          hostlist[i] = hostlist[j]
          hostlist[j] = tmp
        } else if (worst[hostlist[j]] == worst[hostlist[i]] && hostlist[j] < hostlist[i]) {
          # Tie-break: lexical by host string for stable-ish output
          tmp = hostlist[i]
          hostlist[i] = hostlist[j]
          hostlist[j] = tmp
        }
      }
    }

    first = 1
    for (i = 1; i <= n; i++) {
      h = hostlist[i]

      if (!first) print "\n---\n"
      first = 0

      print "### üñ•Ô∏è " h "\n"

      ipk = norm_host(h)
      if (ipk in hostline) {
        print "**Inventory:** `" hostline[ipk] "`\n"
      }

      # Print severities in priority order
      for (order = 1; order <= 5; order++) {
        found = 0

        # Only print a severity header if it exists for this host
        for (s in sev_seen) {
          split(s, x, SUBSEP)
          if (x[1] != h) continue

          sev = x[2]
          if (sev_rank(sev) != order) continue

          if (!found) {
            printf "#### %s %s\n\n", sev_icon(sev), toupper(sev)
            found = 1
          }

          for (k in title) {
            split(k, y, SUBSEP)
            if (y[1] != h || y[2] != sev) continue

            printf "- **%s** (`%s`) ‚Äî %d match(es)\n", title[k], y[3], count[k]
            if (details[k] != "") {
              print "  **Details:**" details[k] "\n"
            }
            if (urls[k] != "") print urls[k]
            print ""
          }
        }
      }
    }
  }'
} > "$MD_OUT"

echo "[+] Report written:"
echo "    Markdown: $MD_OUT"
echo "    CSV     : $CSV_OUT"

